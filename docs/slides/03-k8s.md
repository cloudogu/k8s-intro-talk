# Solution: <br/>Container orchestrator



<img data-src="images/k8s_logo.svg" class="centered" width=70%/>
Note: 
* *one* solution: k8s!



#### Kubernetes (k8s)

You will see the following features hands-on:  

* scheduling containers on multiple nodes
* scaling out (scaling horizontally)
* load balancing
* self healing
* rolling updates



<!-- .slide: data-background-image="images/door.jpg"  -->

Note: 
Wie der Titel schon sagt: Fallen wir mit der T√ºr ins Haus und deployen etwas auf K8s
Quelle: https://pixabay.com/photos/door-weathered-blue-input-5178133/



## üèãÔ∏è Cluster access

```bash
# Start container with all tools necessary
$ docker run -it cloudogu/k8s-training

# Create cluster config 
$ k8s-training-auth fdt 2020

# Test connection: no error means success
$ kubectl version
```

Note:
* Image laden kann bei TN etwas dauern. Bitten dies als erstes durchzuf√ºhren.
* Erkl√§ren was es mit dem Docker Image auf sich hat: Verbindung zum Cluster und einige n√ºtzliche Tools
* Kubectl erkl√§ren



## First deployment

```bash
$ NAME=think-of-something-unique

$ kubectl create deployment $NAME --image=cloudogu/hello-k8s

# Success?
$ k get deployment $NAME
```

Note:
* Unique: We all share one cluster
* cloudogu/hello-k8s: Demo image containing a Node.js web app




## Access via the internet

```bash
k expose deployment $NAME --port=80 --target-port 8080 --type=LoadBalancer

# Query EXTERNAL-IP, then open in browser
k get service $NAME
```
Note: We'll talk about info in browser soon



<!-- .slide: style="text-align: center;" -->
<img data-src="https://i.giphy.com/media/z9sFrQMfEME5a/giphy.webp" width="90%" class="centered"/>
<font size="1">üåê https://i.giphy.com/media/z9sFrQMfEME5a/giphy.webp</font>

Note: 
* Started container and made it accessible via internet. But: This could be done with plain docker as well!



<!-- .slide: data-background-image="images/hardware.jpg"  -->
Note:
* Interessant: Auf welcher Hardware l√§uft das eigentlich?
* Um das zu verstehen, m√ºssen wir uns das Deployment genauer anschauen

https://pixabay.com/photos/server-space-the-server-room-dark-2160321/



## Deployment ‚ûú Pod ‚ûú Container

<img data-src="images/deploy-pod-container.svg" class="centered" width=30%/>

```bash
$ k get pod | grep $NAME
```

Note: 
* Deployment -> Verwaltet Pods (f√ºr horizontale Skalierung - dazu gleich mehr)
* Pods k√∂nnen mehrere Container enthalten, die Zugriff auf gleiches Netzwerk und Storage haben  
   (n√ºtzlich in der Praxis: Anwendungscontainer kann erg√§nzt werden f√ºr zB Metriken, Datenbankverbindung, ServiceMesh)  
   -> zu viel f√ºr diesen Vortrag => Pod ‚âà Container
* Pods ist die Resource, die K8s auf die HW verteilt



## Pod ‚ûú Node

<img data-src="images/pod-node.svg" class="centered" width=45%/>


```bash
$ k get pod -owide
$ k get node
```

Note:
* Containers are scheduled on multiple nodes ‚ûú HA & LB




<!-- .slide: data-background-image="images/rubber-ducks.jpg"  -->
<h2 style="text-align: right; color: black;">High availability?</h2>
<br/><br/><br/><br/><br/><br/><br/>

Note: HA - with only one container?
https://unsplash.com/photos/fXls-tVemno



## Scaling out 

```bash
$ k scale deployment $NAME --replicas=3
$ k get deployment $NAME
$ k get pod | grep $NAME
```

Note: 
Now: Multple instances - next: take care of load balancing 



## Load Balancing

* Reload app in browser multiple times (look at "`pod:`")
* or run script:

```bash
$ EXTERNAL_IP=w.x.y.z
$ while [ 1 ]; do echo $(curl -s http://$EXTERNAL_IP/api/hostName); done
```



## Services

<img data-src="images/services.svg" class="centered" width=45%/>

Note: zwei Aufgaben 
* Cloud LB -> Cluster
* LB -> Pods

-> Ausfallsicherheit und Lastverteilung out of the box.
-> Kubernetes tut noch mehr f√ºr Ausfallsicherheit: Self healing



## Self healing

```bash
$ EXTERNAL_IP=w.x.y.z
$ while [ 1 ]; do echo $(curl -s http://$EXTERNAL_IP/api/hostName); done
```

```bash
$ k get pod | grep $NAME

$ PODNAME=one-of-your-pods
$ k delete pod $PODNAME

$ k get deployment $NAME
$ k get pod
```



## Rolling update

```bash
$ EXTERNAL_IP=w.x.y.z
$ while [ 1 ]; do 
    echo $(curl -s --connect-timeout 1 http://$EXTERNAL_IP/api/appVersion);
  done
```

```bash
$ k get pod | grep $NAME
$ kubectl set image deploy $NAME hello-k8s=cloudogu/hello-k8s:1.9.1
$ watch "kubectl get pod | grep $NAME"
```

Note:
* `hello-k8s=` chooses the container to update
* Why timeout? K8s not yet configured to find out when application is ready to receive traffic
* Readable version of script
```bash
$ EXTERNAL_IP=w.x.y.z
$ while [ 1 ]
do
  echo $(date '+%Y-%m-%d %H:%M:%S') $(curl -s --connect-timeout 1 http://${EXTERNAL_IP}/api/appVersion)
  done
```
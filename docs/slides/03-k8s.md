# Solution: <br/>Container orchestrator



<img data-src="images/k8s_logo.svg" class="centered" width=70%/>
Note: 
* *one* solution: k8s!



#### Kubernetes (k8s)

<p class="fragment">You will see the following features hands-on:  </p>
<ul>
    <li class="fragment">Scheduling containers on multiple nodes</li>
    <li class="fragment">Scaling out (scaling horizontally)</li>
    <li class="fragment">Load balancing</li>
    <li class="fragment">Self healing</li>
    <li class="fragment">Rolling updates</li>
</ul>



<!-- .slide: data-background-image="images/door.jpg"  -->

Note: 
As the title says: Let's plunge into k8s and deploy some apps.
Image Source: https://pixabay.com/photos/door-weathered-blue-input-5178133/

Would this image be a better match? https://pixabay.com/photos/swan-lake-white-brown-swim-3677137/
!-- .slide: data-background-image="images/swan-3677137_1920.jpg"  -->



## üèãÔ∏è Cluster access

```bash
# Start container with all tools necessary
$ docker run -it cloudogu/k8s-training

# Create cluster config 
$ k8s-training-auth fdt 2020

# Test connection: no error means success
$ kubectl version
```

Note:
* Loading images can take a while depending on internet connetion ‚ûú Very first thing to do
* PASTE all listings into shared notes - execute:  docs/slides/printListings.sh
* Explain docker image: saves time by providing all tools necessary for this session, including cluster authentication
* Explain kubectl



## First deployment

```bash
$ NAME=think-of-something-unique

$ kubectl create deployment $NAME --image=cloudogu/hello-k8s

# Success?
$ k get deployment $NAME
```

Note:
* Unique: We all share one cluster
* cloudogu/hello-k8s: Demo image containing a Node.js web app
* `k` - common alias; saves time and space; set up in our container; used on slides from now on




## Access via the internet

```bash
k expose deployment $NAME --port=80 --target-port 8080 --type=LoadBalancer

# Query EXTERNAL-IP, then open in browser
k get service $NAME
```
Note: We'll talk about info in browser soon



<!-- .slide: style="text-align: center;" -->

<img data-src="images/spongebob-boring.webp" width="90%" class="centered"/>

<font size="1">üåê https://media.giphy.com/media/z9sFrQMfEME5a/giphy.gif</font>
Note: 
* Started container and made it accessible via internet. But: This could be done with plain docker as well!



<!-- .slide: data-background-image="images/hardware.jpg"  -->
Note:
* Question: On what HW does this run makes topic more interesting
* To understand: Closer look at Deployment necessary

Image Source: https://pixabay.com/photos/server-space-the-server-room-dark-2160321/



## Deployment ‚ûú Pod ‚ûú Container

<img data-src="images/deploy-pod-container.svg" class="centered" width=30%/>

```bash
$ k get pod | grep $NAME
```

Note: 
* Deployment ‚ûú manages Pods   
  (for scaling out - we'll do that in a couple of mins)
* Pod can contain multiple containers sharing e.g. network and storage.
  (useful for use cases like exposing metrics, connecting DB, integrate into ServiceMesh)
  ‚ûú Only side note for this talk => Pod ‚âà Container  
* Pods is the resource that is scheduled on HW by k8s



## Pod ‚ûú Node

<img data-src="images/pod-node.svg" class="centered" width=45%/>


```bash
$ k get pod -owide
$ k get node
```

Note:
* Containers are scheduled on multiple nodes ‚ûú HA & LB




<!-- .slide: data-background-image="images/rubber-ducks.jpg"  -->
<h2 style="text-align: right; color: black;">High availability?</h2>
<br/><br/><br/><br/><br/><br/><br/>

Note: HA - with only one container?
Image Source: https://unsplash.com/photos/fXls-tVemno



## Scaling out 

```bash
$ k scale deployment $NAME --replicas=3
$ k get deployment $NAME
$ k get pod | grep $NAME
```

Note: 
Now: Multiple instances - next: take care of load balancing 



## Load Balancing

* Reload app in browser multiple times (look at "`pod:`")
* or run script:

```bash
# k get service $NAME
$ EXTERNAL_IP=w.x.y.z
$ while [ 1 ]; do echo $(curl -s http://$EXTERNAL_IP/api/hostName); done
```
Note: How does this work? ‚ûú Services



## Services

<img data-src="images/services.svg" class="centered" width=45%/>

Note: To tasks
* Cloud LB ‚ûú Cluster
* LB ‚ûú Pods

‚ûú High Availability and Load Balancing out of the box.  
‚ûú Has more features regarding HA: Self healing



## Self healing

```bash
# New terminal (or use tmux)
$ docker run -it cloudogu/k8s-training
$ k8s-training-auth fdt 2020

# k get service $NAME
$ EXTERNAL_IP=w.x.y.z 
$ while [ 1 ]; do echo $(curl -s http://$EXTERNAL_IP/api/hostName); done
```

```bash
$ k scale deployment $NAME --replicas=2
$ k get pod | grep $NAME

$ PODNAME=one-of-your-pods
$ k delete pod $PODNAME

$ k get pod | grep $NAME
```
Note:
* $ EXTERNAL_IP=$(k get svc $NAME -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
* tmux
  * Split pane: Ctrl+b %
  * Navigate between panes: Ctrl+b cursor right or left 
  * Scroll mode: Ctrl+b [ - then cursor or mouse wheel 



## Rolling update

```bash
$ EXTERNAL_IP=w.x.y.z
$ while [ 1 ]; do 
    echo $(curl -s --connect-timeout 1 http://$EXTERNAL_IP/api/appVersion);
  done
```

```bash
# Other terminal
$ k scale deployment $NAME --replicas=5
$ k get pod | grep $NAME
$ k set image deploy $NAME hello-k8s=cloudogu/hello-k8s:1.9.1
$ k get pod | grep $NAME
```

Note:
* loop similar to previous slide, except `appVersion` and `connect-timeout` - can be written into one line!
* Why timeout? K8s not yet configured to find out when application is ready to receive traffic
* `hello-k8s=` chooses the container to update
* Server side rollout

Readable version of script
```sh
$ EXTERNAL_IP=w.x.y.z
$ while [ 1 ]
do
  echo $(date '+%Y-%m-%d %H:%M:%S') $(curl -s --connect-timeout 1 http://${EXTERNAL_IP}/api/appVersion)
  done
```